<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
        * {
            margin: 0;
            padding: 0;
        }
        canvas {
            background: gray;
            margin: 50px auto 0;
            display: block;
            background: yellow;
        }
        </style>
    </head>
    <body>
    <canvas id="canvas" width="400" height="400"></canvas>
    </body>
</html>
<script src="../lib/index.js"></script>
<script>
    let ctx = document.getElementById('canvas')
    let gl = ctx.getContext('webgl')
    
    const VERTEX_SHADER_SOURCE = `
    // 声明attribute变量,只传递顶点数据(不能再片元着色器中使用)
    attribute vec4 aPosition;
    attribute vec4 aColor;
    varying vec4 vColor;

    uniform mat4 mat;
    // 必须存在main函数
        void main(){
            // 绘制点的坐标
            gl_Position = mat * aPosition;
            vColor = aColor;
        }
    `
    // 片元着色器
    // vec4(0.0,0.0,0.0,1.0) r g b a 
    const FRAGMENT_SHADER_SOURCE = `
    // 使用uniform控制颜色
    // 指定精度
        precision lowp float;
        varying vec4 vColor;
        void main () {
            gl_FragColor = vColor;
        }
    `
    // 执行绘制
    // 绘制的图形，从那个开始，使用几个顶点
    const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)

    const aPosition = gl.getAttribLocation(program, 'aPosition')
    const aColor = gl.getAttribLocation(program, 'aColor')
    const mat = gl.getUniformLocation(program, 'mat')

    // 缓冲区对象
    const points = new Float32Array([
        0.75, 1.0, -0.6, 1.0, 0.0,0.0,
        0.25, -1.0,-0.6, 1.0, 0.0,0.0,
        1.0, -1.0,-0.6, 1.0, 0.0,0.0,

        0.75, 1.0,-0.5, 0.0, 1.0,0.0,
        0.25, -1.0,-0.5, 0.0, 1.0,0.0,
        1.0, -1.0,-0.5, 0.0, 1.0,0.0,

        0.75, 1.0,-0.4, 0.0, 0.0,1.0,
        0.25, -1.0,-0.4, 0.0, 0.0,1.0,
        1.0, -1.0,-0.4, 0.0, 0.0,1.0,

        -0.75, 1.0,-0.6, 1.0, 0.0,0.0,
        -0.25, -1.0,-0.6, 1.0, 0.0,0.0,
        -1.0, -1.0,-0.6, 1.0, 0.0,0.0,

        -0.75, 1.0,-0.5, 0.0, 1.0,0.0,
        -0.25, -1.0,-0.5, 0.0, 1.0,0.0,
        -1.0, -1.0,-0.5, 0.0, 1.0,0.0,

        -0.75, 1.0,-0.4, 0.0, 0.0,1.0,
        -0.25, -1.0,-0.4, 0.0, 0.0,1.0,
        -1.0, -1.0,-0.4, 0.0, 0.0,1.0,
    ])
    const buffer = gl.createBuffer();
    const BYTES = points.BYTES_PER_ELEMENT;

    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW)

    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, BYTES * 6, 0)
    gl.enableVertexAttribArray(aPosition)

    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, BYTES * 6, BYTES * 3)
    gl.enableVertexAttribArray(aColor)

    gl.drawArrays(gl.TRIANGLES,0,3*6)
    let eyex = 0.0;
    let eyey = -0.1;
    let eyez = 0.2;
    function animation () {
        const vm = getViewMatrix(eyex, eyey, eyez, 0.0,0.0,0.0,0.0,0.6,0.0);
        console.log(vm)
        const person = getPerspective(150, ctx.width / ctx.height, 100,1);
        gl.enable(gl.DEPTH_TEST)
        gl.uniformMatrix4fv(mat, false, minMatrix(vm, person));
        gl.drawArrays(gl.TRIANGLES, 0, 3 * 6);
    }
    animation()

    document.onkeydown = function (e) {
        switch(e.keyCode){
            case 37: eyex += 0.01;break;
            case 38: eyex -= 0.01;break;
            case 39: eyey += 0.01;break;
            case 40: eyey -= 0.01;break;
        }
      animation()
    }

// 创建透视投影矩阵
    // function getPerspective(fov, aspect, far, near){
    //     fov = fov * Math.PI / 180;
    //     return new Float32Array([
    //         1 / (aspect * Math.tan(fov/ 2)), 0, 0, 0,
    //         0, 1/(Math.tan(fov / 2)), 0, 0,
    //         0,0,-(far + near)/(far - near), -(2 * far * near)/(far - near),
    //         0,0,-1,0,
    //     ])
    // }
    // let eyex = 0.0
    // let eyey = -0.1
    // let eyez = 0.2
    
    // function draw () {
    //     console.log(eyex,eyey,eyez)
    //     const vm = getViewMatix(eyex,eyey,eyez,0.0,0.0,0.0,0.0,0.6,0.0)
    //     const perspective = getPerspective(150,ctx.width/ctx.height, 100, 1)

    //     gl.enable(gl.DEPTH_TEST)

    //     gl.uniformMatrix4fv(mat, false, minMatrix(vm, perspective))
    //     gl.drawArrays(gl.TRIANGLES, 0, 3 * 6)
    //     // requestAnimationFrame(animation)
    // }

    
    // draw()

    // document.onkeydown = function (e) {
    //     console.log(e.keyCode)
    //     switch(e.keyCode){
    //         case 37: eyex += 0.1;break;
    //         case 38: eyex -= 0.1;break;
    //         case 39: eyey += 0.1;break;
    //         case 40: eyey -= 0.1;break;
    //     }
    //     draw()
    // }



</script>
