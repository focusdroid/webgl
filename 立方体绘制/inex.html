<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
        * {
            margin: 0;
            padding: 0;
        }
        canvas {
            background: gray;
            margin: 50px auto 0;
            display: block;
            background: yellow;
        }
        </style>
    </head>
    <body>
    <canvas id="canvas" width="600" height="600"></canvas>
    </body>
</html>
<script src="../lib/index.js"></script>
<script>
    let ctx = document.getElementById('canvas')
    let gl = ctx.getContext('webgl')
    
    const VERTEX_SHADER_SOURCE = `
    // 声明attribute变量,只传递顶点数据(不能再片元着色器中使用)
    attribute vec4 aPosition;
    attribute vec4 aColor;
    varying vec4 vColor;

    uniform mat4 mat;
    // 必须存在main函数
        void main(){
            // 绘制点的坐标
            gl_Position = mat * aPosition;
            vColor = aColor;
        }
    `
    // 片元着色器
    // vec4(0.0,0.0,0.0,1.0) r g b a 
    const FRAGMENT_SHADER_SOURCE = `
    // 使用uniform控制颜色
    // 指定精度
        precision lowp float;
        varying vec4 vColor;
        void main () {
            gl_FragColor = vColor;
        }
    `
    // 执行绘制
    // 绘制的图形，从那个开始，使用几个顶点
    const program = initShader(gl, VERTEX_SHADER_SOURCE, FRAGMENT_SHADER_SOURCE)

    const aPosition = gl.getAttribLocation(program, 'aPosition')
    const aColor = gl.getAttribLocation(program, 'aColor')
    const mat = gl.getUniformLocation(program, 'mat')

    // 定点1
    const v0 = [1,1,1];
    const v1 = [-1,1,1];
    const v2 = [-1,-1,1]
    const v3 = [1,-1,1]
    const v4 = [1,-1,-1]
    const v5 = [1,1,-1]
    const v6 = [-1,1,-1]
    const v7 = [-1,-1,-1]
    // 缓冲区对象
    const points = new Float32Array([
      ...v0, ...v1, ...v2, ...v0, ...v2, ...v3, // 前面
      ...v0, ...v3, ...v4, ...v0, ...v4, ...v5, // 右面
      ...v0, ...v5, ...v6, ...v0, ...v6, ...v1, // 上面
      ...v1, ...v6, ...v7, ...v1, ...v7, ...v2, // 左面
      ...v7, ...v4, ...v3, ...v7, ...v3, ...v2, // 底面
      ...v4, ...v7, ...v6, ...v4, ...v6, ...v5, // 后面
    ])
    const buffer = gl.createBuffer();
    const BYTES = points.BYTES_PER_ELEMENT;

    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW)

    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(aPosition)

    // 创建颜色数据
    const color = new Float32Array([
      1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0, 1,0,0,
      0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0, 0,1,0,
      0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1, 0,0,1,
      1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1, 1,1,1,
      0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0, 0,0,0,
      0,1,1, 0,1,1, 0,1,1, 0,1,1, 0,1,1, 0,1,1,
    ])
    const colorBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)
    gl.bufferData(gl.ARRAY_BUFFER, color, gl.STATIC_DRAW)
    gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(aColor)

    let eyex = 3;
    let eyey = 3;
    let eyez = 5;
    let deg = 0
    function draw () {
      deg += 0.01;
      const rotate = getRouteMatrix(deg)
        const vm = getViewMatrix(eyex, eyey, eyez, 0.0,0.0,0.0,0.0,0.6,0.0);
        const perspective = getPerspective(20, ctx.width / ctx.height, 100,1);
        gl.enable(gl.DEPTH_TEST)
        gl.uniformMatrix4fv(mat, false, minMatrix(minMatrix(perspective, vm),rotate));
        gl.drawArrays(gl.TRIANGLES, 0, points.length / 3);

        requestAnimationFrame(draw)
    }
    draw()

</script>
